# 同步系列

所谓同步，就是保证多线程（包括多进程）对共享资源的读写能够安全有效的运行。

根据同步的运用场景的不同，实现同步的方式也是随之一起变化，但是总结下来，这些实现方式之间又有一些共通之处。

不管是互斥锁、读写锁、信号量、CountDownLatch、回环栅栏、Phaser，还是各种分布式锁，它们都是基于对同一个**共享变量（状态变量）**的控制，以达到同步的目的。

互斥锁，state为大于等于1（可重入）表示已加锁，state为0表示未加锁；

读写锁，state的高16位存储读的次数，低16位存储写的次数；

信号量，state存储许可的次数，被使用一次许可减一，被释放一次许可加一；

CountDownLatch，state存储初始次数，countDown()次数减一，当次数减为0的时候await()被激活；

回环栅栏，基于ReentrantLock实现，相当于在CountDownLatch的基础上加了“代”的概念，保证可重复使用；

Phaser，state的高32位存储当前阶段phase，中16位存储当前阶段参与者（任务）的数量parties，低16位存储未完成参与者的数量unarrived，每个阶段的参与者都可以控制，相对于回环栅栏更灵活；

mysql分布式锁，基于数据库的getlock()/releaselock()对共享变量进行控制；

zookeeper分布式锁，基于有序临时节点对共享变量进行控制；

redis分布式锁，基于内存键值对对共享变量进行控制；

总结下来，所有同步器的关键因素只有一个——共享变量，只要能够对共享变量进行精确的控制，就能实现同步，以后出现新的组件我们一样可以根据这条原理使用新的组件来实现分布式同步器。

![](../source/sync.jpg)

## 前言

### 概览

大致包含三大主题：java中的锁、同步器、分布式锁

（1）volatile

（2）synchronized

（3）AQS及Condition

（4）ReentrantLock

（5）ReentrantReadWriteLock

（6）StampedLock

（7）CountDownLatch

（8）Semaphore

（9）CyclicBarrier

（10）Phaser

（11）Mysql实现分布式锁

（12）Redis实现分布式锁

（13）Zookeeper实现分布锁

### 锁

（1）公平锁/非公平锁

公平锁，是指按照线程申请的顺序获取锁。

非公平锁，是指不是按照线程申请的顺序获取锁，有可能后申请的线程反而先获取到锁，假如先来的线程一直获取不到锁，会造成锁饥饿现象。

ReentrantLock中可以通过构造方法指定是否为公平锁，默认为非公平锁，非公平锁的优点在于吞吐量大。

synchronized无法指定为公平锁，一直都是非公平锁。

（2）可重入锁

可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。

ReentrantLock和synchronized都是可重入锁。

（3）独享锁/共享锁

独享锁，是指锁一次只能被一个线程持有。

共享锁，是指锁一次可以被多个线程持有。

ReentrantLock和synchronized都是独享锁，ReadWriteLock的读锁是共享锁，写锁是独享锁。

（4）互斥锁/读写锁

与独享锁/共享锁的概念差不多，是独享锁/共享锁的具体实现。

ReentrantLock和synchronized都是互斥锁

ReadWriteLock是读写锁

（5）乐观锁/悲观锁

悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会发生修改也这么认为，所以一定要加锁。

乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。

悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。

例如CAS 就是乐观锁，而sy就是悲观锁

（6）分段锁

分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。LongAddr里面也用到了**分段**思想。

（7）偏向锁/轻量级锁/重量级锁

这三个锁主要是针对synchronized进行优化使用的，主要是通过对象监视器在对象头中的字段来表明的。

偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。

轻量级锁，是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。

重量级锁，是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。

（8）自旋锁

自旋锁，是指尝试获取锁的线程不会阻塞，而是循环的方式不断尝试，这样的好处是减少线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU。

CAS配合自旋，JUC里面都用了，但是很耗费性能，所以为什么longAdder和LongAccumulate要比AtomLong性能高。

（9）监视器锁

synchronized的实现方式，使用monitorenter和monitorexit来实现。

（10）mutex锁

互斥锁，LockSupport.part()底层是通过mutex实现的。

## JMM


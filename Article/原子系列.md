# 原子系列

原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。

这里文章将其分为四个部分了，下面一个一个来说

## 原子更新基本类型或引用类型

如果是基本类型，则替换其值，如果是引用，则替换其引用地址，这些类主要有：

（1）AtomicBoolean

原子更新布尔类型，内部使用int类型的value存储1和0表示true和false，底层也是对int类型的原子操作。

（2）AtomicInteger

原子更新int类型。

（3）AtomicLong

原子更新long类型。

（4）AtomicReference

原子更新引用类型，通过泛型指定要操作的类。

（5）AtomicMarkableReference

原子更新引用类型，内部使用Pair承载引用对象及是否被更新过的标记，避免了ABA问题。

（6）AtomicStampedReference

原子更新引用类型，内部使用Pair承载引用对象及更新的邮戳，避免了ABA问题。

这几个类的操作基本类似，底层都是调用Unsafe的compareAndSwapXxx()来实现，基本用法如下：

CAS听起来牛逼，其实就是比较加置换罢了，很多地方都有用到

## 原子更新数组中的元素

原子更新数组中的元素，可以更新数组中指定索引位置的元素，这些类主要有

1）AtomicIntegerArray

原子更新int数组中的元素。

（2）AtomicLongArray

原子更新long数组中的元素。

（3）AtomicReferenceArray

原子更新Object数组中的元素。

## 原子更新对象中的字段

原子更新对象中的字段，可以更新对象中指定字段名称的字段，这些类主要有：

（1）AtomicIntegerFieldUpdater

原子更新对象中的int类型字段。

（2）AtomicLongFieldUpdater

原子更新对象中的long类型字段。

（3）AtomicReferenceFieldUpdater

原子更新对象中的引用类型字段。

这里注意对象需要使用volatile关键字

### 高性能原子类

高性能原子类，是java8中增加的原子类，它们使用分段的思想，把不同的线程hash到不同的段上去更新，最后再把这些段的值相加得到最终的值，这些类主要有：

推荐文章：

[Java JUC longAddr](https://juejin.im/post/5d4bde1e5188250541791e45)

[**Java并发编程之LongAdder和LongAccumulator源码探究**](https://www.cnblogs.com/huangjuncong/p/9152510.html)

（1）Striped64

下面四个类的父类。

（2）LongAccumulator

long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等。

（3）LongAdder

LongAdder是JDK 1.8 新增的原子类，基于Striped64实现。 从官方文档看，LongAdder在高并发的场景下会比AtomicLong 具有更好的性能，代价是消耗更多的内存空间：

long类型的累加器，LongAccumulator的特例，只能用来计算加法，且从0开始计算。

（4）DoubleAccumulator

double类型的聚合器，需要传入一个double类型的二元操作，可以用来计算各种聚合操作，包括加乘等。

（5）DoubleAdder

double类型的累加器，DoubleAccumulator的特例，只能用来计算加法，且从0开始计算。

## Usafe解析

Unsafe为我们提供了访问底层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。

我们发现它有一个属性叫theUnsafe，我们直接通过反射拿到它即可。所以我们普通用户是可以用这个功能的

使用Unsafe的putXXX()方法，我们可以修改任意私有字段的值

### 创建一个实体的集中方法

（1）通过构造方法实例化一个类；

（2）通过Class实例化一个类；

（3）通过反射实例化一个类；

（4）通过克隆实例化一个类；

（5）通过反序列化实例化一个类；

（6）通过Unsafe实例化一个类；

### 总结

使用Unsafe几乎可以操作一切：

（1）实例化一个类；

`Unsafe.allocateInstance()`只会给对象分配内存，并不会调用构造方法，所以如果构造方法里面有任何操作，这是不会执行的。

（2）修改私有字段的值；

​    一旦我们通过反射调用得到字段age，我们就可以使用Unsafe将其值更改为任何其他int值。（当然，这里也可以通过反射直接修改

（3）抛出checked异常；

​    我们知道如果代码抛出了checked异常，要不就使用try...catch捕获它，要不就在方法签名上定义这个异常，但是，通过Unsafe我们可以抛出一个checked异常，同时却不用捕获或在方法签名上定义它。

（4）使用堆外内存；

   如果进程在运行过程中JVM上的内存不足了，会导致频繁的进行GC。理想情况下，我们可以考虑使用堆外内存，这是一块不受JVM管理的内存。使用Unsafe的allocateMemory()我们可以直接在堆外分配内存，这可能非常有用，但我们要记住，这个内存不受JVM管理，因此我们要调用freeMemory()方法手动释放它

（5）CAS操作；

​		JUC下面大量使用了CAS操作，它们的底层是调用的Unsafe的CompareAndSwapXXX()方法。这种方式广泛运用于无锁算法，与java中标准的悲观锁机制相比，它可以利用CAS处理器指令提供极大的加速。比如，我们可以基于Unsafe的compareAndSwapInt()方法构建线程安全的计数器。

（6）阻塞/唤醒线程；

​    JVM在上下文切换的时候使用了Unsafe中的两个非常牛逼的方法park()和unpark()。当一个线程正在等待某个操作时，JVM调用Unsafe的park()方法来阻塞此线程。当阻塞中的线程需要再次运行时，JVM调用Unsafe的unpark()方法来唤醒此线程。我们之前在分析java中的集合时看到了大量的LockSupport.park()/unpark()，它们底层都是调用的Unsafe的这两个方法。

## AtomInteger

AtomicInteger是java并发包下面提供的原子类，主要操作的是int类型的整型，通过调用底层Unsafe的CAS等方法实现原子操作.原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征.这里注意，之所以AtomInteger效率比AtomLongAdder低，就是CAS加自旋的乐观锁机制引起的，具体可参见上文文章，所以他会不断得尝试操作，这里和数据库的ACID的A不同的是没有回滚操作。

### 总结

（1）AtomicInteger中维护了一个使用volatile修饰的变量value，保证可见性；

（2）AtomicInteger中的主要方法最终几乎都会调用到Unsafe的compareAndSwapInt()方法保证对变量修改的原子性。

## AtomicStampedReference

AtomicStampedReference是java并发包下提供的一个原子类，它能解决其它原子类无法解决的ABA问题

ABA问题通常发生在无锁结构中

文章中举例了一部分ABA问题，例如常见的栈结构就很经典，如果最后只判断栈顶的话，最后肯定整个结构就不对了。

### 解决ABA问题

（1）版本号

比如，上面的栈结构增加一个版本号用于控制，每次CAS的同时检查版本号有没有变过。还有一些数据结构喜欢使用高位存储一个邮戳来保证CAS的安全。例如AtomStampedRefernce其实对于Markable的话，也是差不多，只是不是维护版本号，而是一个Bool值来判断。

（2）不重复使用节点的引用

比如，执行push()入栈操作的时候新建一个节点传入，而不是复用节点1的引用；

（3）直接操作元素而不是节点

比如，上面的栈结构push()方法不应该传入一个节点（Node），而是传入元素值（int的value）

对于Stamped其实解决方式也是这样

（1）如果元素值和版本号都没有变化，并且和新的也相同，返回true；

（2）如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。

可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。

首先，使用版本号控制；

其次，不重复使用节点（Pair）的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；

最后，外部传入元素值及版本号，而不是节点（Pair）的引用。

### 总结

（1）在多线程环境下使用无锁结构要注意ABA问题；

（2）ABA的解决一般使用版本号来控制，并保证数据结构使用元素值来传递，且每次添加元素都新建节点承载元素值；

（3）AtomicStampedReference内部使用Pair来存储元素值及其版本号
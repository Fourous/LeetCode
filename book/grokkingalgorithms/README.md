## 算法图解

![算法图解封面](./../../source/algorithm.jpg)

### 第一章

* 图算法设计跟踪用户的AI系统
* KNN编写推荐系统
* NP完全问题，求解不可解问题的近似解



#### 二分查找

二分查找能到O(log2n)复杂度

二分查找实现比较简单，但是也有很多细节，主要实现

二分查找有两种实现方式，一个是递归一个是非递归形式

#### 大O表示法

常见的大O表示法

* O(log2n) 对数时间 例如二分查找 
* O(n) 线性时间例如简单查找
* O(nlogn) 快排算法
* O(n2) 选择排序
* O(n!)  阶乘时间，图算法中的旅行商问题

### 第二章

数组和链表都有各自的优缺点

链表的优势在插入方面，不需要连续的内存，但是查找上需要遍历，达到O(n)

数组优势在查找上，只需要O(1)，删除上面不如链表，需要移动元素

#### 选择排序

选择排序的算法复杂度达到了O(n2)，不是一种比较好的实现方式

### 第三章

递归只是在代码可读性和理解上面比较容易，但是对性能帮助不是很大，很多情况用循环反而性能更高，这看你主要看中哪点

**基线条件和递归条件**

递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。

### 第四章

#### D&C

D&C 分而治之思想

一般包含两个步骤：

(1)  找出基线条件，这种条件必须尽可能简单。
(2)  不断将问题分解(或者说缩小规模)，直到符合基线条件。

**辗转相除法**，又称**欧几里得算法**（英语：Euclidean algorithm），是求最大公约数的算法

#### 扩展欧几里得算法

我们知道欧几里得算法一般用于都是求解最大公约数，我们熟知的RSA加密就用到了扩展欧几里得算法。

对整数做因数分解是很困难的事情，所以人们把两个大质数相乘的乘积公开作为加密密钥，即RSA算法的原理。而RSA算法又使用到欧几里得算法的扩展。

扩展的欧几里得算法是这样一个问题

例如对于a b我们将最大公约数记为gcd(a,b)

现在我们有这样一个问题 求出ax+by=gcd(a,b)中的x,y取值

参考：[扩展的欧几里得算法和RSA加密](https://blog.text.wiki/2018/09/26/rsa.html)

有关欧几里得算法和扩展欧几里得算法及其RSA加密相关查看

[RSA和欧几里得](https://github.com/Fourous/LeetCode/tree/master/Article/RSA和欧几里得.md)

快速排序证明使用了归纳证明法，例如我可以证明空数组和一个元素数组是有效的，那么就可以证明两个元素有效，一直递推，即证明

快速排序在最好情况下，复杂度到了O(nlog2n)但是在最坏情况下，复杂度是O(n2)

#### 比较快速排序和合并排序

快速排序在平均情况下的运行时间为O(nlogn) 而合并排序运行时间总是O(nlogn)

我们常说的大O(nlogn)其实和真正的运行时间不是成完全对应关系，更多是线性对应，也就是

时间=C*O(nlogn) 其中C为常量，比如每次打印时候间隔10S，则这个C值为10

对于快速排序，由于常量值比合并排序的小，所以实际时间运行得也比较少，而我们平时遇到情况大多数都不可能都是最糟情况，实际平均就是最糟的，所以结论就是快速比合并要快。

#### 平均情况和最糟情况

在快速排序中，最好情况就是从已经排序数组中选取中间的值，复杂度为O(nlogn)，最坏情况就是从第一个位置开始为O(n2)，其实只要你每次随机选择一个数字作为基准值，最佳情况也就是平均情况。

### 第五章

#### 散列函数

散列函数“将输入映射到数字”，这种散列函数一般满足两个要求

* 它必须是一致的，输入一个数字，返回的数字必须是唯一的，而不会出现不一致情况
* 最理想情况，它应将不同的输入映射到不同的数字

散列表经常用于缓存场景里面,缓存是一种常见的网站加速方式

#### 冲突

避免冲突，我们需要有

* 较低的填装因子

* 良好的散列函数

装填因子=散列表包含元素个数/位置总数

好的散列函数会让数据均匀分布，可以研究一下SHA函数

### 第六章

#### BFS

BFS是广度优先搜索的简称，我们使用广度优先搜索可以

* 编写国际象棋AI，看能走多少步可以获胜

* 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将

  READED改为READER需要编辑一个地方

* 根据你的人际关系网络找到关系最近的医生

图是数据结构里面算是最难的一个了，但是目前BFS是应该最有用的(作者主观)

BFS是一种图的查找算法，主要解决两个问题

* 第一类问题:从节点A出发，有前往节点B的路径吗?

* 第二类问题:从节点A出发，前往节点B的哪条路径最短?

队列是一种FIFO（先进先出结构）栈是一种LIFO（后进先出结构）

作者是通过队列实现BFS搜索，emm，这里可能只是为了提一下队列和栈

### 第七章

狄克斯特拉算法（*Dijkstra*）

BFS是找出段数最少的路径，对于图里面有权重的情况，最经典的还是用*Dijkstra*算法，当然对于图中有环的情况，可能导致不适用

* 仅当权重为正时狄克斯特拉算法才管用。
*  如果图中包含负权边，请使用贝尔曼福德(Floyd)算法。

### 第八章

学习识别NP完全问题（没有快速算法问题），避免浪费时间去寻找快速算法去解决这个问题，学习近似算法，来快速解决这样的问题。

#### 贪婪算法

贪婪算法很容易理解，每一步都选择局部最优解，得到的就是全局最优解，当然并不是都是这样的，例如在背包问题里面，可能最后得到的解不是最优解，所以贪婪算法应该看作一种近似算法。在一定情况下，是为最优解的。

例如在集合覆盖问题里面，如果按照常规解可能复杂度到了O(n2)，但是贪婪算法能快速得到近似解，符合最后的题意。

#### NP完全问题

NP问题是多项式复杂程度的非确定性问题，也就是比较复杂难以快速解决的问题，此书没有这样的定义，很笼统，列出了例如集合问题等，并做了个归纳

* 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
*  涉及“所有组合”的问题通常是NP完全问题
*  不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
*  如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能就是NP完全问题。  如果问题涉及集合(如广播台集合)且难以解决，它可能就是NP完全问题。
* 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

#### P NP NPC问题

对于NP问题的文章更加详细解释 [NP，P，NPC问题](https://www.jianshu.com/p/dcb0b52f4935)

这里的贪心算法涉及到了NPC问题范畴，这里作战没有继续详述

其实P=NP问题一直是目前信息学的一个难题，用概念来说就是能用多项式时间验证解的问题是否内在多项式时间内找出解。

在决策树算法中，寻找最优决策树是一个NP完全问题。决策树的这一特点，说明我们无法利用计算机在多项式时间内，找出全局最优的解，也正因为如此，大多数决策树算法都采用启发式的算法，如贪心算法，来指导对假设空间的搜索。可以说，决策树最后的结果，是在每一步、每一个节点上做的局部最优选择。决策树得到的结果，是没法保证为全局最优的。

也就是贪心算法并不是全局最优解的，而是利用局部最优解去代替或者去猜测全局最优解，例如对于旅行商问题(TSP问题)，就是一个典型的NPC问题。

### 第九章

#### 动态规划 (DP)

动态规划算法的工作原理。动态规划先解决子问题，再逐步解决大问题。例如最经典的应用地方就是正则匹配里面，就经常使用动态规划来解决。

例如在背包问题里面，我们将背包分解为1kg 2kg 3kg 4kg采用网格，一步一步求解最大价值

但是动态规划也有其局限性，动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。

动态规划基本都是要涉及网格的，很多地方我们都已用DP解决，例如最长公共子串，

### 第十章

#### K近邻法（KNN）

KNN最常用的就是两个，一个是分类，一个是回归预测。

这里注意，虽然找的例子是采用毕达哥拉斯定理求的距离，但是不是意味着KNN就最适合用这个距离表示相似度，常用的其实是余弦相似度，余弦相似度不计算两个矢量的距离，而比较它们的角度。KNN影响很大因素其实关于你选择的特征。

#### 机器学习简介

KNN类似的应用还有很多，当然这里作者都是一笔带过没详细讲，举例是OCR和朴素贝叶斯分类器

### 第十一章

概述十个算法

#### 树

二叉查找树，对于二叉查找树和二分查找很类似，其实二分查找知识点很窄最难的其实一个是你要建模，再就是边界问题，OJ上有类似的题目

相比于二分查找，查找树的复杂度虽然为logn但是其删除和插入速度不是n而是logn，最经典的二叉查找树其实就是B树，研究二叉查找最好直接研究B树，如果对数据库感兴趣还可以研究B树，红黑树，堆， 伸展树。

#### 反向索引

反向索引是一个很有用的数据结构，一个散 列表，将单词映射到包含它的页面。这种数据结构被称为反向索引(inverted index)，常用于创 建搜索引擎。如果你对搜索感兴趣，从反向索引着手研究是不错的选择。

例如我搜索there时候，其实事先我做了个反向索引，那就直接返回A B页面，这样我点击就直接点击A 或者B去找就行了。

#### 傅里叶变换

傅立叶变换的应用场景非常高。例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音 乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的 贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理!

#### 并行算法

并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点 是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核， 算法的速度也不可能提高一倍，其中的原因有两个。

* 并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之 间分配这项任务呢?如果让每个内核对其中500个元素进行排序，再将两个排好序的数组 合并成一个有序数组，那么合并也是需要时间的。
* 负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核 A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意 味着有那么50秒，内核B在忙死忙活，而内核A却闲得很!你如何均匀地分配工作，让两 个内核都一样忙呢?

要改善性能和可扩展性，并行算法可能是不错的选择

#### MapReduce

有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时， 完全可以在笔记本电脑上运行它，但如果需要数百个内核呢?在这种情况下，可让算法在多台计 算机上运行。MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。

分布式算法能解决单机情况运行速度慢的问题，分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理 念:映射(map)函数和归并(reduce)函数。

#### 布隆过滤器和HyperLogLog

**布隆过滤器**

布隆过滤器提供了解决之道。布隆过滤器是一种概率型数据结构，它提供的答案有可能不对， 但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散 列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。简而言之，布隆过滤器并不是一种确定算法，而是找到一个海量集合是否存在的你需要的数据问题。

布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有 URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况

有个结论得记住，就是只可能出现误报的情况，不可能出现漏报，也就是可能给你的答案是存在，但是实际是不存在的可能也有，但是如果给你不存在，那就真的是不存在。

**HyperLogLog**

HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案， 但也八九不离十，而占用的内存空间却少得多。

如果面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法!

#### SHA 算法

我们之前在散列算法里面知道，如果你搜索一个东西，其复杂度是O(1),但是你希望这个分布是比较均匀的

有一种散列函数是安全散列算法(secure hash algorithm，SHA)函数。给定一个字符串，SHA返回其散列值。

SHA是一个散列函数，它生成一个散列值——一个较短的字符串。 用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。

SHA有很多应用，例如我们可以比较文件是否相同

你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个4 GB 的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送 给朋友，而可计算它们的SHA散列值，再对结果进行比较。

我们熟知的密码加密也有应用，例如我们登录时候，大多数后端服务器并不是使用明文存储密码然后比较，而是使用SHA加密，采用加密后的字符串跟你密码加密后比较，而且得到SHA加密后的字符串是没办法反转到原来密码的。

SHA实际上是一系列算法:SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1 已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。 当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。

#### 局部敏感的散列算法

局部敏感说简单点就是如果你原来的加密字符细微改动了局部，希望加密后的字符也只产生细微改动，如果你使用SHA的话，这个时候可能你原来密码改了一个字母，得到的字符串完全不一样，这在安全上虽然比较好，但是很多场景还是需要这种局部敏感的。

在这种情况下，可使用Simhash。 如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比 较散列值来判断两个字符串的相似程度，这很有用!

* Google使用Simhash来判断网页是否已搜集。
*  老师可以使用Simhash来判断学生的论文是否是从网上抄的。
*  Scribd允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容!这个

网站可使用Simhash来检查上传的内容是否与小说《哈利·波特》类似，如果类似，就自动拒绝。

需要检查两项内容的相似程度时，Simhash很有用

#### Diffie-Hellman 密钥交换

这里有必要提一提Diffie-Hellman算法，它以优雅的方式解决了一个古老的问题:如何对消息 进行加密，以便只有收件人才能看懂呢?

Diffie-Hellman就是解决这个的，其有两个特点

* 双方无需知道加密算法。他们不必会面协商要使用的加密算法。

* 要破解加密的消息比登天还难。（整数分解问题，我们熟知的扩展的欧几里得算法）

Diffie-Hellman算法及其替代者RSA依然被广泛使用。如果你对加密感兴趣，先着手研究 Diffie-Hellman算法是不错的选择:它既优雅又不难理解。

#### 线性规划

这里作者也是一笔带过，线性规划问题是解决在有限条件下求解最大化的问题。

所有的图算法都可 使用线性规划来实现。线性规划是一个宽泛得多的框架，图问题只是其中的一个子集

线性规划使用Simplex算法，这个算法很复杂，因此本书没有介绍。如果你对最优化感兴趣， 就研究研究线性规划吧


## 算法图解
### 第一章

* 图算法设计跟踪用户的AI系统
* KNN编写推荐系统
* NP完全问题，求解不可解问题的近似解



#### 二分查找

二分查找能到O(log2n)复杂度

二分查找实现比较简单，但是也有很多细节，主要实现

二分查找有两种实现方式，一个是递归一个是非递归形式

#### 大O表示法

常见的大O表示法

* O(log2n) 对数时间 例如二分查找 
* O(n) 线性时间例如简单查找
* O(nlogn) 快排算法
* O(n2) 选择排序
* O(n!)  阶乘时间，图算法中的旅行商问题

### 第二章

数组和链表都有各自的优缺点

链表的优势在插入方面，不需要连续的内存，但是查找上需要遍历，达到O(n)

数组优势在查找上，只需要O(1)，删除上面不如链表，需要移动元素

#### 选择排序

选择排序的算法复杂度达到了O(n2)，不是一种比较好的实现方式

### 第三章

递归只是在代码可读性和理解上面比较容易，但是对性能帮助不是很大，很多情况用循环反而性能更高，这看你主要看中哪点

**基线条件和递归条件**

递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。

### 第四章

#### D&C

D&C 分而治之思想

一般包含两个步骤：

(1)  找出基线条件，这种条件必须尽可能简单。
(2)  不断将问题分解(或者说缩小规模)，直到符合基线条件。

**辗转相除法**，又称**欧几里得算法**（英语：Euclidean algorithm），是求最大公约数的算法

#### 扩展欧几里得算法

我们知道欧几里得算法一般用于都是求解最大公约数，我们熟知的RSA加密就用到了扩展欧几里得算法。

对整数做因数分解是很困难的事情，所以人们把两个大质数相乘的乘积公开作为加密密钥，即RSA算法的原理。而RSA算法又使用到欧几里得算法的扩展。

扩展的欧几里得算法是这样一个问题

例如对于a b我们将最大公约数记为gcd(a,b)

现在我们有这样一个问题 求出ax+by=gcd(a,b)中的x,y取值

参考：[扩展的欧几里得算法和RSA加密](https://blog.text.wiki/2018/09/26/rsa.html)

有关欧几里得算法和扩展欧几里得算法及其RSA加密相关查看

[RSA和欧几里得](https://github.com/Fourous/LeetCode/tree/master/Article/RSA和欧几里得.md)

快速排序证明使用了归纳证明法，例如我可以证明空数组和一个元素数组是有效的，那么就可以证明两个元素有效，一直递推，即证明

快速排序在最好情况下，复杂度到了O(nlog2n)但是在最坏情况下，复杂度是O(n2)

#### 比较快速排序和合并排序

快速排序在平均情况下的运行时间为O(nlogn) 而合并排序运行时间总是O(nlogn)

我们常说的大O(nlogn)其实和真正的运行时间不是成完全对应关系，更多是线性对应，也就是

时间=C*O(nlogn) 其中C为常量，比如每次打印时候间隔10S，则这个C值为10

对于快速排序，由于常量值比合并排序的小，所以实际时间运行得也比较少，而我们平时遇到情况大多数都不可能都是最糟情况，实际平均就是最糟的，所以结论就是快速比合并要快。

#### 平均情况和最糟情况

在快速排序中，最好情况就是从已经排序数组中选取中间的值，复杂度为O(nlogn)，最坏情况就是从第一个位置开始为O(n2)，其实只要你每次随机选择一个数字作为基准值，最佳情况也就是平均情况。

### 第五章

### 第六章

### 第七章

### 第八章

### 第九章

### 第十章

### 第十一章

